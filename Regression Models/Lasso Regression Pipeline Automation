def pipeline_training(X,y):
    model = linear_model.Lasso()
    imputer = IterativeImputer(imputation_order = 'random',
                               initial_strategy = 'median',
                               max_iter = 10, sample_posterior = False)

    imputation_pipeline = Pipeline([
                      ('imputer', imputer),
                      ('model', model)])
    params = {}
    params['model__alpha'] = [4e-15, 3e-12, 5e-10, 7e-9, 6e-8, 5e-7, 8e-3, 6e-2, 5e-2, 0.1]
    params['model__selection'] = ['cyclic']
    params['model__max_iter'] = [15000]
    params['model__tol'] = [0.003, 0.001]
    params['model__normalize'] = ['False']

    grid_cv = GridSearchCV(imputation_pipeline, params, cv = 3,refit = 'neg_mean_squared_error',
                                   scoring=['neg_mean_squared_error', 
                                            'neg_mean_absolute_error', 
                                            'r2'], n_jobs = -1)
    optimized_lasso = Pipeline([
                      ('robust', RobustScaler()),
                      ('grid_cv', grid_cv)
     ])

    optimized_lasso.fit(X,y)

    # Sorting cross validation results
    grid_validation = pd.DataFrame(grid_cv.cv_results_).sort_values(ascending = True, by = 'rank_test_neg_mean_squared_error')
    string = 'Negative Root Mean Absolute Error: {accuracy:.2f}'
    print(string.format(accuracy = grid_cv.best_score_))


    # Conversion of lasso coefficients for interpretability
    lasso_coefs = pd.DataFrame(grid_cv.best_estimator_['model'].coef_, columns = ['Lasso Coefficients'],index = X.columns)
    optimized_lasso_coefs = lasso_coefs[abs(lasso_coefs['Lasso Coefficients']) > 0]
    exponent_transform = optimized_lasso_coefs.copy()
    house_area_interp = exponent_transform.loc['HouseArea',:] - 1
    columns = pd.Series(exponent_transform.index)
    categorical_index = columns[~columns.isin(continuous)].values
    categorical_interp = 10**exponent_transform.loc[continuous_index,:] - 1
    ordinal_index = columns[columns.isin(ordinals)].values
    ordinal_interp = exponent_transform.loc[ordinal_index,:] * 100
    continuous_index = columns[columns.isin(continuous)].values
    continuous_interp = exponent_transform.loc[continuous_index,:].drop('HouseArea') * 100
    # Returns the cross validation object, trained pipeline object, and converted betas for insertion into visualizations
    return optimized_lasso, grid_cv, ordinal_interp, continuous_interp, categorical_interp, house_area_interp
